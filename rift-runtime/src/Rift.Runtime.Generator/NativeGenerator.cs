using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;

namespace Rift.Runtime.Generator;

[Generator]
public class NativeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            (x, _) => x is ClassDeclarationSyntax node && node.GetNameSpace() == "Rift.Runtime.Fundamental.Interop.Natives",
            (x, _) => (ClassDeclarationSyntax) x.Node);

        var compilation = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilation,
            (spc, source) => Execute(spc, source.Left, source.Right));
    }

        private static void Execute(SourceProductionContext context,
        Compilation                                     compilation,
        ImmutableArray<ClassDeclarationSyntax>          classDeclarations)
    {
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            var className = classDeclarationSyntax.Identifier.Text;

            var builder = new CodeWriter();

            builder.AppendLine($"""
                                // <auto-generated/>

                                #pragma warning disable 0649
                                #nullable enable

                                using System.Text.Unicode;
                                using System;
                                using System.Text;
                                using System.Buffers;

                                namespace {namespaceName};

                                """);

            using (builder.BeginScope($"unsafe partial class {classSymbol.Name}"))
            {
                var methods = classSymbol.GetMembers()
                                         .OfType<IMethodSymbol>()
                                         .Where(x => x is { Kind: SymbolKind.Method, IsStatic: true, IsPartialDefinition: true });

                foreach (var methodSymbol in methods)
                {
                    var fnParams                       = methodSymbol.GetParams();
                    var delegateUnmanagedPointerString = fnParams.GetDelegateUnmanagedPointerString();

                    builder.AppendLine($"private static {delegateUnmanagedPointerString} _{methodSymbol.Name};");

                    using (builder.BeginScope(
                               $"public static partial {methodSymbol.ReturnType} {methodSymbol.Name}({fnParams.GetParametersString()})"))
                    {
                        fnParams.BuildUtf8ConvertCode(builder);

                        fnParams.BuildCallAndReturnDelegateUnmanagedPointer(builder, $"_{methodSymbol.Name}");
                    }

                    builder.AppendLine();
                }
            }

            context.AddSource($"{className}.g.cs", builder.ToString());
        }
    }
}